package org.immersed.gaffe.generation;

import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;
import static org.immersed.gaffe.generation.Constants.EXCEPTION_GENERIC;
import static org.immersed.gaffe.generation.Constants.PACKAGE;
import static org.immersed.gaffe.generation.Util.className;
import static org.immersed.gaffe.generation.Util.utilityMethodName;

import java.io.IOException;
import java.nio.file.Files;
import java.util.Arrays;

import org.immersed.gaffe.FunctionalInterfaceSpec;

import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;
import com.squareup.javapoet.TypeVariableName;

/**
 * Generates a static class that adds "throwing" methods for each interface
 * generated by the {@link InterfaceGenerator}.
 * 
 * @author Dan Avila
 *
 */
final class UtilityClassGenerator
{
    private final ProjectSpec proj;

    public UtilityClassGenerator(ProjectSpec spec)
    {
        this.proj = spec;
    }

    /**
     * Generates the utility class, and associated test case.
     * 
     * @throws IOException
     * @throws ClassNotFoundException
     */
    public void generateUtilityClass() throws IOException
    {
        MethodSpec utilityConstructor = MethodSpec.constructorBuilder()
                                                  .addModifiers(PRIVATE)
                                                  .build();

        TypeSpec.Builder utilitySpec = TypeSpec.classBuilder(className(proj, proj.sourceFolder()))
                                               .addModifiers(PUBLIC, FINAL)
                                               .addMethod(utilityConstructor);

        for (FunctionalInterfaceSpec spec : proj.functionalInterfaces())
        {
            installUtilityMethod(utilitySpec, spec);
        }

        TypeSpec utilityClass = utilitySpec.build();
        JavaFile file = JavaFile.builder(Constants.PACKAGE, utilityClass)
                                .build();
        file.writeTo(Files.createDirectories(proj.sourceFolder()));

        new UtilityClassTestGenerator(utilityClass, proj).generateUtilityClassTest();
    }

    private void installUtilityMethod(Builder utilityClass, FunctionalInterfaceSpec spec)
    {
        TypeVariableName[] methodGenerics = classGenericVars(spec);
        TypeVariableName[] parameterGenerics = parameterGenerics(spec);

        ClassName paramClassName = ClassName.get(spec.packageName(PACKAGE), spec.className());
        ParameterizedTypeName paramType = ParameterizedTypeName.get(paramClassName, parameterGenerics);

        String methodName = utilityMethodName(spec);
        utilityClass.addMethod(MethodSpec.methodBuilder(methodName)
                                         .addModifiers(PUBLIC, STATIC)
                                         .addParameter(paramType, methodName)
                                         .addTypeVariables(Arrays.asList(methodGenerics))
                                         .returns(returnType(spec))
                                         .addCode("return $L;\n", methodName)
                                         .build());
    }

    private TypeName returnType(FunctionalInterfaceSpec spec)
    {
        ClassName returnClassName = ClassName.get(spec.superType());

        String[] superGenerics = spec.superGenerics();

        if (superGenerics.length == 0)
        {
            return TypeName.get(spec.superType());
        }

        TypeVariableName[] superGenericVars = new TypeVariableName[superGenerics.length];
        for (int i = 0; i < superGenericVars.length; i++)
        {
            superGenericVars[i] = TypeVariableName.get(superGenerics[i]);
        }

        return ParameterizedTypeName.get(returnClassName, superGenericVars);
    }

    private TypeVariableName[] parameterGenerics(FunctionalInterfaceSpec spec)
    {
        String[] superGenerics = spec.superGenerics();
        TypeVariableName[] superGenericVars = new TypeVariableName[superGenerics.length];
        for (int i = 0; i < superGenericVars.length; i++)
        {
            superGenericVars[i] = TypeVariableName.get(superGenerics[i]);
        }

        TypeVariableName[] classGenericVars = Arrays.copyOf(superGenericVars, superGenericVars.length + 1);
        classGenericVars[classGenericVars.length - 1] = TypeVariableName.get(EXCEPTION_GENERIC);

        return classGenericVars;
    }

    private TypeVariableName[] classGenericVars(FunctionalInterfaceSpec spec)
    {
        String[] superGenerics = spec.typeDeclarations();
        TypeVariableName[] superGenericVars = new TypeVariableName[superGenerics.length];
        for (int i = 0; i < superGenericVars.length; i++)
        {
            superGenericVars[i] = TypeVariableName.get(superGenerics[i]);
        }

        TypeVariableName[] classGenericVars = Arrays.copyOf(superGenericVars, superGenericVars.length + 1);
        classGenericVars[classGenericVars.length - 1] = TypeVariableName.get(EXCEPTION_GENERIC, Throwable.class);

        return classGenericVars;
    }
}
