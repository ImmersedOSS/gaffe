package org.immersed.gaffe.generation;

import static javax.lang.model.element.Modifier.FINAL;
import static javax.lang.model.element.Modifier.PRIVATE;
import static javax.lang.model.element.Modifier.PUBLIC;
import static javax.lang.model.element.Modifier.STATIC;
import static org.immersed.gaffe.generation.Constants.EXCEPTION_GENERIC;
import static org.immersed.gaffe.generation.Constants.PACKAGE;

import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.Arrays;
import java.util.stream.IntStream;

import javax.lang.model.element.Modifier;

import org.immersed.gaffe.FunctionalInterfaceSpec;

import com.squareup.javapoet.AnnotationSpec;
import com.squareup.javapoet.ClassName;
import com.squareup.javapoet.CodeBlock;
import com.squareup.javapoet.JavaFile;
import com.squareup.javapoet.MethodSpec;
import com.squareup.javapoet.ParameterizedTypeName;
import com.squareup.javapoet.TypeName;
import com.squareup.javapoet.TypeSpec;
import com.squareup.javapoet.TypeSpec.Builder;
import com.squareup.javapoet.TypeVariableName;

import io.github.classgraph.ClassInfo;

/**
 * Generates a static class that adds "throwing" methods for each interface
 * generated by the {@link InterfaceGenerator}.
 * 
 * @author Dan Avila
 *
 */
final class UtilityClassGenerator
{
    private static final ClassName className(ProjectSpec spec, Path location)
    {
        boolean isTest = location.equals(spec.testFolder());

        StringBuilder buffer = new StringBuilder("Gaffe");
        buffer.append(spec.projectName());
        buffer.append(isTest ? "Test" : "");

        return ClassName.get(Constants.PACKAGE, buffer.toString());
    }

    private final ProjectSpec proj;

    public UtilityClassGenerator(ProjectSpec spec)
    {
        this.proj = spec;
    }

    /**
     * Generates the utility class, and associated test case.
     * 
     * @throws IOException
     * @throws ClassNotFoundException
     */
    public void generateUtilityClass() throws IOException
    {
        MethodSpec utilityConstructor = MethodSpec.constructorBuilder()
                                                  .addModifiers(PRIVATE)
                                                  .build();

        TypeSpec.Builder utilitySpec = TypeSpec.classBuilder(className(proj, proj.sourceFolder()))
                                               .addModifiers(PUBLIC, FINAL)
                                               .addMethod(utilityConstructor);

        for (FunctionalInterfaceSpec spec : proj.functionalInterfaces())
        {
            installUtilityMethod(utilitySpec, spec);
        }

        TypeSpec utilityClass = utilitySpec.build();
        JavaFile file = JavaFile.builder(Constants.PACKAGE, utilityClass)
                                .build();
        file.writeTo(Files.createDirectories(proj.sourceFolder()));

        generateUtilityClassTest(utilityClass);
    }

    private void generateUtilityClassTest(TypeSpec utilityClass) throws IOException
    {
        TypeSpec.Builder utilityTestClass = TypeSpec.classBuilder(className(proj, proj.testFolder()))
                                                    .addModifiers(PUBLIC, FINAL);

        AnnotationSpec testAnnotation = AnnotationSpec.builder(ClassName.get("org.junit.jupiter.api", "Test"))
                                                      .build();

        for (FunctionalInterfaceSpec spec : proj.functionalInterfaces())
        {
            ThrowingInterfaceSpec throwingSpec = new ThrowingInterfaceSpec(spec);

            String utilityMethod = utilityMethodName(spec);

            MethodSpec.Builder mB = MethodSpec.methodBuilder(new StringBuilder().append("test")
                                                                                .append(utilityMethod)
                                                                                .append("CanThrowCheckedException")
                                                                                .toString())
                                              .addModifiers(Modifier.PUBLIC)
                                              .addAnnotation(testAnnotation);

            MethodSpec m = throwingSpec.originalMethod();
            String params = IntStream.range(0, m.parameters.size())
                                     .mapToObj(i -> Character.toString((char) ('a' + i)))
                                     .reduce((a, b) -> a + "," + b)
                                     .map(s -> s.length() == 1 ? s : String.format("(%s)", s))
                                     .orElse("()");

            TypeName superInterface = throwingSpec.superInterface();

            if (superInterface instanceof ParameterizedTypeName)
            {
                ParameterizedTypeName parameterizedType = (ParameterizedTypeName) superInterface;
                // TypeName[] types = new TypeName[parameterizedType.typeArguments.size()];
                // Arrays.setAll(types, i -> types[i] = TypeVariableName.get("?"));
                superInterface = parameterizedType.rawType;
            }

            mB.addCode(CodeBlock.builder()
                                .add("$L iface = $L($L -> {\n", superInterface, utilityMethod, params)
                                .indent()
                                .addStatement("throw new $T()", IOException.class)
                                .unindent()
                                .add("});\n")
                                .addStatement("iface.toString()")
                                .build());

            utilityTestClass.addMethod(mB.build());
        }

        JavaFile file = JavaFile.builder(Constants.PACKAGE, utilityTestClass.build())
                                .addStaticImport(ClassName.get(Constants.PACKAGE, utilityClass.name), "*")
                                .build();
        file.writeTo(Files.createDirectories(proj.testFolder()));
    }

    private void installUtilityMethod(Builder utilityClass, FunctionalInterfaceSpec spec)
    {
        TypeVariableName[] methodGenerics = classGenericVars(spec);
        TypeVariableName[] parameterGenerics = parameterGenerics(spec);

        ClassName paramClassName = ClassName.get(spec.packageName(PACKAGE), spec.className());
        ParameterizedTypeName paramType = ParameterizedTypeName.get(paramClassName, parameterGenerics);

        String methodName = utilityMethodName(spec);
        utilityClass.addMethod(MethodSpec.methodBuilder(methodName)
                                         .addModifiers(PUBLIC, STATIC)
                                         .addParameter(paramType, methodName)
                                         .addTypeVariables(Arrays.asList(methodGenerics))
                                         .returns(returnType(spec))
                                         .addCode("return $L;\n", methodName)
                                         .build());
    }

    private String utilityMethodName(FunctionalInterfaceSpec spec)
    {
        ClassInfo superClass = spec.superClassInfo();
        return "throwing" + superClass.getSimpleName()
                                      .replace("$", "");
    }

    private TypeName returnType(FunctionalInterfaceSpec spec)
    {
        ClassName returnClassName = ClassName.get(spec.superType());

        String[] superGenerics = spec.superGenerics();

        if (superGenerics.length == 0)
        {
            return TypeName.get(spec.superType());
        }

        TypeVariableName[] superGenericVars = new TypeVariableName[superGenerics.length];
        for (int i = 0; i < superGenericVars.length; i++)
        {
            superGenericVars[i] = TypeVariableName.get(superGenerics[i]);
        }

        return ParameterizedTypeName.get(returnClassName, superGenericVars);
    }

    private TypeVariableName[] parameterGenerics(FunctionalInterfaceSpec spec)
    {
        String[] superGenerics = spec.superGenerics();
        TypeVariableName[] superGenericVars = new TypeVariableName[superGenerics.length];
        for (int i = 0; i < superGenericVars.length; i++)
        {
            superGenericVars[i] = TypeVariableName.get(superGenerics[i]);
        }

        TypeVariableName[] classGenericVars = Arrays.copyOf(superGenericVars, superGenericVars.length + 1);
        classGenericVars[classGenericVars.length - 1] = TypeVariableName.get(EXCEPTION_GENERIC);

        return classGenericVars;
    }

    private TypeVariableName[] classGenericVars(FunctionalInterfaceSpec spec)
    {
        String[] superGenerics = spec.typeDeclarations();
        TypeVariableName[] superGenericVars = new TypeVariableName[superGenerics.length];
        for (int i = 0; i < superGenericVars.length; i++)
        {
            superGenericVars[i] = TypeVariableName.get(superGenerics[i]);
        }

        TypeVariableName[] classGenericVars = Arrays.copyOf(superGenericVars, superGenericVars.length + 1);
        classGenericVars[classGenericVars.length - 1] = TypeVariableName.get(EXCEPTION_GENERIC, Throwable.class);

        return classGenericVars;
    }
}
